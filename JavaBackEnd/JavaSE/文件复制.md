**JDK原生技术的文件复制**

- 



# 缓冲流

```java
import org.junit.jupiter.api.Test;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileCopy {
    /**
     * Function: 通过缓冲流复制文件
     * Input: 源文件，目标文件
     * Output：复制成功与否
     * KeyPoints: 缓冲流
     */
    public static boolean copyFileByBufferedStream(File source, File target) {
        //入参校验
        if(!entryParametersVerification(source,target)) {
            System.out.println("copyFileByBufferedStream入参校验失败");
            return false;
        }

        BufferedInputStream inputStream = null;
        BufferedOutputStream outputStream = null;
        try {
            inputStream = new BufferedInputStream(new FileInputStream(source));
            outputStream = new BufferedOutputStream(new FileOutputStream(target));

            byte[] bufferedArray = new byte[1024]; //1024Bytes = 1KB
            int length = 0;

            long start = System.currentTimeMillis();
            while ((length = inputStream.read(bufferedArray)) != -1) {
                /*
                 * Notice:从输入流中最后一次读取到缓冲数组中，该缓冲数组一不定是满的
                 * */
                outputStream.write(bufferedArray,0, length);
            }
            outputStream.flush();

            System.out.println("copyFileByBufferedStream 复制量: " + source.length() + "Bytes 用时：" + (System.currentTimeMillis() - start) + "ms");

        } catch (IOException e) {
            System.out.println("copyFileByBufferedStream 复制文件出错");
            e.printStackTrace();
            return false;
        } finally {
            try {
                if(inputStream != null) {
                    inputStream.close();
                }
                if(outputStream != null) {
                    outputStream.close();
                }
            } catch (IOException e) {
                System.out.println("关闭流出错");
                e.printStackTrace();
            }
        }

        return true;
    }

    /**
     * Function：文件复制入参校验
     * Input: 源文件，目标文件
     * Output：源文件和目标文件是否符合一定要求
     * KeyPoints：
     *  1.源文件：是否存在
     *  2.目标文件：是否存在，是否覆盖
     */
    public static boolean entryParametersVerification(File source, File target) {
        if(!source.exists()) {
            System.out.println("源文件不存在");
            return false;
        }

        if(!target.exists()) {
            System.out.println("目标文件不存在，创建");
            File targetDir = new File(target.getParent());
            if (!targetDir.mkdirs()) {
                System.out.println("目标文件夹创建失败");
                return false;
            }
        }

        if(target.exists()) {
            System.out.println("目标文件已存在，自动覆盖目标文件");
        }

        return true;
    }
}


/**
 * 测试点：
 * 目标文件不存在的情况
 * 目标文件已存在的情况
 */
class FileCopyTest {
    @Test
    public void testCopyFileByBufferedStream() {
        File sourceFile = new File("c:/users/sunliju/desktop/source/test.docx");
        File targetFile = new File("c:/users/sunliju/desktop/target/test.docx");

        boolean status = FileCopy.copyFileByBufferedStream(sourceFile, targetFile);
        System.out.println("复制状态：" + status);
    }
}
```



# NIO

```java
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;

public class FileCopy {
    /**
     * Function: 通过缓冲流复制文件
     * Input: 源文件，目标文件
     * Output：复制成功与否
     * KeyPoints: NIO（异步IO中的文件流通道）
     */
    public static boolean copyFileByNIO(File source, File target) {
        //入参校验
        if(!entryParametersVerification(source,target)) {
            System.out.println("copyFileByNIO入参校验失败");
            return false;
        }

        FileInputStream inputStream = null;
        FileOutputStream outputStream = null;

        FileChannel inputChannel = null;
        FileChannel outputChannel = null;
        try {
            inputStream = new FileInputStream(source);
            outputStream = new FileOutputStream(target);

            inputChannel = inputStream.getChannel();
            outputChannel = outputStream.getChannel();

            long  start = System.currentTimeMillis();

            outputChannel.transferFrom(inputChannel,0,inputChannel.size());

            System.out.println("copyFileByNIO 复制量: " + inputChannel.size() +"Bytes 用时：" + (System.currentTimeMillis() - start) + "ms");
        } catch (IOException e) {
            System.out.println("copyFileByNIO 复制文件出错");
            e.printStackTrace();
        } finally {
            try {
                if(inputStream != null) {
                    inputStream.close();
                }
                if(inputChannel != null) {
                    inputChannel.close();
                }
                if(outputStream != null) {
                    outputStream.close();
                }
                if(outputChannel != null) {
                    outputChannel.close();
                }
            } catch (IOException e) {
                System.out.println("关闭流出错");
                e.printStackTrace();
            }
        }
        return true;
    }

    /**
     * Function：文件复制入参校验
     * Input: 源文件，目标文件
     * Output：源文件和目标文件是否符合一定要求
     * KeyPoints：
     *  1.源文件：是否存在
     *  2.目标文件：是否存在，是否覆盖
     */
    public static boolean entryParametersVerification(File source, File target) {
        if(!source.exists()) {
            System.out.println("源文件不存在");
            return false;
        }

        if(!target.exists()) {
            System.out.println("目标文件不存在，创建");
            File targetDir = new File(target.getParent());
            if (!targetDir.mkdirs()) {
                System.out.println("目标文件夹创建失败");
                return false;
            }
        }

        if(target.exists()) {
            System.out.println("目标文件已存在，自动覆盖目标文件");
        }

        return true;
    }
}


/**
 * 测试点：
 * 目标文件不存在的情况
 * 目标文件已存在的情况
 */
class FileCopyTest {
    @Test
    public void testCopyFileByNIO() {
        File sourceFile = new File("c:/users/sunliju/desktop/source/test.docx");
        File targetFile = new File("c:/users/sunliju/desktop/target/test.docx");

        boolean status = FileCopy.copyFileByNIO(sourceFile, targetFile);
        System.out.println("复制状态：" + status);
    }
}
```

# Files工具类

```java
import org.junit.jupiter.api.Test;

import java.io.File;
import java.nio.file.Files;

public class FileCopy {
    /**
     * Function: 通过缓冲流复制文件
     * Input: 源文件，目标文件
     * Output：复制成功与否
     * KeyPoint: JDK1.7提供的Files工具类
     */
    public static boolean copyFileByFiles(File source, File target) {
        if(!source.exists()) {
            System.out.println("源文件不存在");
            return false;
        }

        if(!target.exists()) {
            System.out.println("目标文件不存在，创建");
            File targetDir = new File(target.getParent());
            if (!targetDir.mkdirs()) {
                System.out.println("目标文件夹创建失败");
                return false;
            }
        }

        if(target.exists()) {
            System.out.println("目标文件已存在，先删除目标文件。如果直接复制则会抛出java.nio.file.FileAlreadyExistsException");
            if (target.delete()) {
                System.out.println("已存在的目标文件删除成功");
            } else {
                System.out.println("已存在的目标文件删除失败, 继续执行会抛出java.nio.file.FileAlreadyExistsException");
                return false;
            }
        }

        try {
            long start = System.currentTimeMillis();
            Files.copy(source.toPath(), target.toPath());
            System.out.println("copyFileByFiles 复制量：" + source.length() +"Bytes 用时：" + (System.currentTimeMillis() - start) + "ms");
        } catch (Exception e) {
            System.out.println("copyFileByFiles 复制文件出错");
            e.printStackTrace();
            return false;
        }

        return true;
    }
}


/**
 * 测试点：
 * 目标文件不存在的情况
 * 目标文件已存在的情况
 */
class FileCopyTest {
    @Test
    public void testCopyFileByFiles() {
        File sourceFile = new File("c:/users/sunliju/desktop/source/test.docx");
        File targetFile = new File("c:/users/sunliju/desktop/target/test.docx");

        boolean status = FileCopy.copyFileByFiles(sourceFile, targetFile);
        System.out.println("复制状态：" + status);
    }
}
```















